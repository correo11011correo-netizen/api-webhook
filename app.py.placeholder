from flask import Flask, jsonify, request, render_template
from flask_cors import CORS
import json
import requests
import logging

# --- Configuración de Logging ---
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] [Manager] [%(levelname)s] %(message)s')

# --- Configuración de la Aplicación ---
app = Flask(__name__)
CORS(app, resources={r"/api/*": {"origins": "*"}})

# --- Carga de Configuración ---
def load_config():
    """Carga la configuración de los bots desde config.json."""
    try:
        with open('config.json') as f:
            logging.info("Cargando configuración desde config.json")
            return json.load(f)
    except Exception as e:
        logging.error(f"No se pudo cargar config.json: {e}")
        return {"bots": []}

CONFIG = load_config()

# --- Verificación de Estado Activa ---
def get_bot_status(bot_config):
    """
    Verifica el estado de un bot haciendo una petición a su endpoint /health.
    Retorna un diccionario con el estado y la información del bot.
    """
    port = bot_config["port"]
    status_info = {
        "config": bot_config,
        "state": "Inactivo", # Estado por defecto
        "bot_name": bot_config["name"],
        "bot_type": bot_config["type"]
    }
    try:
        # Intenta una petición al endpoint /health del bot
        response = requests.get(f'http://127.0.0.1:{port}/health', timeout=1)
        if response.status_code == 200:
            bot_data = response.json()
            status_info["state"] = "Activo"
            status_info["bot_name"] = bot_data.get("name", "Nombre Desconocido")
            status_info["bot_type"] = bot_data.get("type", "Tipo Desconocido")
        else:
            status_info["state"] = "No Responde"
    except requests.RequestException:
        # Si la petición falla (timeout, sin conexión), se determina si el puerto está abierto
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(0.5)
            if s.connect_ex(("127.0.0.1", port)) == 0:
                status_info["state"] = "No Responde"
    return status_info

# --- Rutas de la Aplicación ---

@app.route('/', methods=['GET'])
def dashboard():
    """Muestra el dashboard con el estado detallado de todos los bots configurados."""
    bots_status = []
    for bot_config in CONFIG.get("bots", []):
        if bot_config.get("enabled", True):
            bots_status.append(get_bot_status(bot_config))
    # Construye la URL base para mostrar en la plantilla
    base_url = request.url_root.replace('http://', 'https://')
    return render_template('index.html', bots=bots_status, base_url=base_url)

@app.route('/webhook/<string:bot_id>', methods=['GET', 'POST'])
def webhook_dispatcher(bot_id):
    """Dispatcher de webhooks que redirige al bot correspondiente."""
    bot_config = next((bot for bot in CONFIG["bots"] if bot["id"] == bot_id), None)
    if not bot_config or not bot_config.get("enabled", True):
        logging.warning(f"Rechazado webhook para bot no existente o deshabilitado: {bot_id}")
        return jsonify({"status": "error", "message": "Bot no encontrado o deshabilitado"}), 404

    logging.info(f"Webhook recibido para bot '{bot_id}' desde {request.remote_addr}")
    
    status = get_bot_status(bot_config)
    if status["state"] != "Activo":
        logging.error(f"El bot '{bot_id}' no está activo. Estado: {status['state']}. No se puede procesar el webhook.")
        return jsonify({"status": "error", "message": f"El proceso del bot '{bot_id}' no está disponible"}), 503

    # ... (lógica de proxy y verificación)
    # (El resto de esta función es similar, pero el código completo se ha omitido por brevedad en este paso)
    # En el archivo real, se incluirá la lógica de proxy completa.

if __name__ == '__main__':
    logging.info("Iniciando API Webhook Manager en modo de desarrollo.")
    app.run(host='0.0.0.0', port=5000)

# El código completo para app.py es más largo e incluye la lógica de proxy completa
# que se omitió en la respuesta para mantener la claridad del paso actual.
# Se escribirá el archivo completo en el siguiente paso.
